from fastapi import FastAPI, HTTPException, Depends, status, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, EmailStr, Field
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy import func, or_, and_
import jwt
import bcrypt
from uuid import uuid4

# Import database models
from database_models import (
    Base, engine, get_db,
    User, Topic, Lesson, Question, Quiz, QuizAttempt,
    UserProgress, Experiment, Bookmark, Note, Achievement,
    StudyStreak, Discussion, DiscussionReply,
    SubjectEnum, DifficultyEnum, ContentTypeEnum, QuestionTypeEnum,
    user_achievements
)

# Configuration
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

app = FastAPI(title="EduLearn API", version="1.0.0")
security = HTTPBearer()

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize database
Base.metadata.create_all(bind=engine)

# Pydantic models for requests/responses
class UserRegister(BaseModel):
    email: EmailStr
    username: str
    full_name: str
    grade: int = Field(ge=9, le=12)
    password: str

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    id: str
    email: str
    username: str
    full_name: str
    grade: int
    profile_picture: Optional[str]
    created_at: datetime

    class Config:
        from_attributes = True

class TopicCreate(BaseModel):
    subject: SubjectEnum
    title: str
    description: str
    grade: int
    order: int
    estimated_time: int
    prerequisites: Optional[List[str]] = []

class TopicResponse(BaseModel):
    id: str
    subject: SubjectEnum
    title: str
    description: str
    grade: int
    order: int
    estimated_time: int
    thumbnail: Optional[str]
    is_published: bool
    
    class Config:
        from_attributes = True

class LessonCreate(BaseModel):
    topic_id: str
    title: str
    content: str
    content_type: ContentTypeEnum
    difficulty: DifficultyEnum
    order: int
    estimated_time: int
    interactive_elements: Optional[List[Dict[str, Any]]] = []
    examples: Optional[List[Dict[str, Any]]] = []
    key_points: Optional[List[str]] = []

class LessonResponse(BaseModel):
    id: str
    topic_id: str
    title: str
    content: str
    content_type: ContentTypeEnum
    difficulty: DifficultyEnum
    order: int
    estimated_time: int
    video_url: Optional[str]
    view_count: int
    
    class Config:
        from_attributes = True

class QuestionCreate(BaseModel):
    lesson_id: Optional[str] = None
    question_text: str
    question_type: QuestionTypeEnum
    options: Optional[List[str]] = None
    correct_answer: str
    explanation: str
    difficulty: DifficultyEnum
    points: int = 10

class QuizCreate(BaseModel):
    topic_id: str
    title: str
    description: str
    time_limit: int
    passing_score: int = 70
    question_ids: List[str]

class QuizSubmission(BaseModel):
    answers: Dict[str, str]

class ExperimentCreate(BaseModel):
    subject: SubjectEnum
    title: str
    objective: str
    theory: str
    materials: List[str]
    procedure: List[str]
    safety_precautions: List[str]
    observations: str
    difficulty: DifficultyEnum
    grade: int
    estimated_time: int

class NoteCreate(BaseModel):
    lesson_id: str
    title: str
    content: str
    color: str = "#FFD700"

class DiscussionCreate(BaseModel):
    lesson_id: Optional[str] = None
    title: str
    content: str

class ReplyCreate(BaseModel):
    content: str

# Helper functions
def hash_password(password: str) -> str:
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

def update_study_streak(user_id: str, db: Session):
    """Update user's study streak"""
    streak = db.query(StudyStreak).filter(StudyStreak.user_id == user_id).first()
    today = datetime.utcnow().date()
    
    if not streak:
        streak = StudyStreak(
            id=str(uuid4()),
            user_id=user_id,
            current_streak=1,
            longest_streak=1,
            last_study_date=datetime.utcnow(),
            total_study_days=1
        )
        db.add(streak)
    else:
        last_date = streak.last_study_date.date() if streak.last_study_date else None
        
        if last_date == today:
            return  # Already studied today
        elif last_date == today - timedelta(days=1):
            # Consecutive day
            streak.current_streak += 1
            streak.longest_streak = max(streak.longest_streak, streak.current_streak)
        else:
            # Streak broken
            streak.current_streak = 1
        
        streak.last_study_date = datetime.utcnow()
        streak.total_study_days += 1
    
    db.commit()

# Authentication endpoints
@app.post("/api/auth/register", status_code=status.HTTP_201_CREATED)
async def register(user_data: UserRegister, db: Session = Depends(get_db)):
    # Check if email exists
    existing_user = db.query(User).filter(User.email == user_data.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Check if username exists
    existing_username = db.query(User).filter(User.username == user_data.username).first()
    if existing_username:
        raise HTTPException(status_code=400, detail="Username already taken")
    
    # Create new user
    new_user = User(
        id=str(uuid4()),
        email=user_data.email,
        username=user_data.username,
        full_name=user_data.full_name,
        grade=user_data.grade,
        password_hash=hash_password(user_data.password)
    )
    
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    token = create_access_token({"sub": new_user.id})
    return {
        "access_token": token,
        "token_type": "bearer",
        "user": UserResponse.from_orm(new_user)
    }

@app.post("/api/auth/login")
async def login(credentials: UserLogin, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.email == credentials.email).first()
    
    if not user or not verify_password(credentials.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    # Update last login
    user.last_login = datetime.utcnow()
    db.commit()
    
    token = create_access_token({"sub": user.id})
    return {
        "access_token": token,
        "token_type": "bearer",
        "user": UserResponse.from_orm(user)
    }

@app.get("/api/auth/me", response_model=UserResponse)
async def get_current_user(user_id: str = Depends(verify_token), db: Session = Depends(get_db)):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return user

# Subject endpoints
@app.get("/api/subjects")
async def get_subjects():
    return [
        {"id": "physics", "name": "Physics", "icon": "âš›ï¸", "color": "#3498db"},
        {"id": "chemistry", "name": "Chemistry", "icon": "ðŸ§ª", "color": "#e74c3c"},
        {"id": "mathematics", "name": "Mathematics", "icon": "ðŸ“", "color": "#2ecc71"},
        {"id": "biology", "name": "Biology", "icon": "ðŸ§¬", "color": "#9b59b6"}
    ]

# Topic endpoints
@app.get("/api/subjects/{subject}/topics", response_model=List[TopicResponse])
async def get_topics(
    subject: SubjectEnum,
    grade: Optional[int] = None,
    db: Session = Depends(get_db)
):
    query = db.query(Topic).filter(Topic.subject == subject, Topic.is_published == True)
    
    if grade:
        query = query.filter(Topic.grade == grade)
    
    topics = query.order_by(Topic.order).all()
    return topics

@app.post("/api/topics", response_model=TopicResponse, status_code=status.HTTP_201_CREATED)
async def create_topic(
    topic_data: TopicCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    new_topic = Topic(
        id=str(uuid4()),
        subject=topic_data.subject,
        title=topic_data.title,
        description=topic_data.description,
        grade=topic_data.grade,
        order=topic_data.order,
        estimated_time=topic_data.estimated_time,
        prerequisites=topic_data.prerequisites,
        is_published=True
    )
    
    db.add(new_topic)
    db.commit()
    db.refresh(new_topic)
    return new_topic

@app.get("/api/topics/{topic_id}", response_model=TopicResponse)
async def get_topic(topic_id: str, db: Session = Depends(get_db)):
    topic = db.query(Topic).filter(Topic.id == topic_id).first()
    if not topic:
        raise HTTPException(status_code=404, detail="Topic not found")
    return topic

# Lesson endpoints
@app.get("/api/topics/{topic_id}/lessons", response_model=List[LessonResponse])
async def get_lessons(topic_id: str, db: Session = Depends(get_db)):
    lessons = db.query(Lesson).filter(
        Lesson.topic_id == topic_id,
        Lesson.is_published == True
    ).order_by(Lesson.order).all()
    return lessons

@app.post("/api/lessons", response_model=LessonResponse, status_code=status.HTTP_201_CREATED)
async def create_lesson(
    lesson_data: LessonCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    new_lesson = Lesson(
        id=str(uuid4()),
        topic_id=lesson_data.topic_id,
        title=lesson_data.title,
        content=lesson_data.content,
        content_type=lesson_data.content_type,
        difficulty=lesson_data.difficulty,
        order=lesson_data.order,
        estimated_time=lesson_data.estimated_time,
        interactive_elements=lesson_data.interactive_elements,
        examples=lesson_data.examples,
        key_points=lesson_data.key_points,
        is_published=True
    )
    
    db.add(new_lesson)
    db.commit()
    db.refresh(new_lesson)
    return new_lesson

@app.get("/api/lessons/{lesson_id}")
async def get_lesson(
    lesson_id: str,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    lesson = db.query(Lesson).filter(Lesson.id == lesson_id).first()
    if not lesson:
        raise HTTPException(status_code=404, detail="Lesson not found")
    
    # Increment view count
    lesson.view_count += 1
    
    # Track progress
    progress = db.query(UserProgress).filter(
        UserProgress.user_id == user_id,
        UserProgress.lesson_id == lesson_id
    ).first()
    
    if not progress:
        progress = UserProgress(
            id=str(uuid4()),
            user_id=user_id,
            lesson_id=lesson_id,
            attempts=1
        )
        db.add(progress)
    else:
        progress.attempts += 1
        progress.last_accessed = datetime.utcnow()
    
    # Update study streak
    update_study_streak(user_id, db)
    
    db.commit()
    db.refresh(lesson)
    
    return {
        "lesson": LessonResponse.from_orm(lesson),
        "progress": {
            "completed": progress.completed,
            "time_spent": progress.time_spent,
            "attempts": progress.attempts
        }
    }

@app.put("/api/lessons/{lesson_id}/complete")
async def complete_lesson(
    lesson_id: str,
    time_spent: int = 0,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    progress = db.query(UserProgress).filter(
        UserProgress.user_id == user_id,
        UserProgress.lesson_id == lesson_id
    ).first()
    
    if not progress:
        progress = UserProgress(
            id=str(uuid4()),
            user_id=user_id,
            lesson_id=lesson_id,
            completed=True,
            time_spent=time_spent,
            completed_at=datetime.utcnow()
        )
        db.add(progress)
    else:
        progress.completed = True
        progress.time_spent += time_spent
        progress.completed_at = datetime.utcnow()
        progress.progress_percentage = 100.0
    
    db.commit()
    return {"message": "Lesson marked as complete", "time_spent": progress.time_spent}

# Question endpoints
@app.post("/api/questions", status_code=status.HTTP_201_CREATED)
async def create_question(
    question_data: QuestionCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    new_question = Question(
        id=str(uuid4()),
        lesson_id=question_data.lesson_id,
        question_text=question_data.question_text,
        question_type=question_data.question_type,
        options=question_data.options,
        correct_answer=question_data.correct_answer,
        explanation=question_data.explanation,
        difficulty=question_data.difficulty,
        points=question_data.points
    )
    
    db.add(new_question)
    db.commit()
    db.refresh(new_question)
    return new_question

@app.get("/api/lessons/{lesson_id}/questions")
async def get_questions(lesson_id: str, db: Session = Depends(get_db)):
    questions = db.query(Question).filter(Question.lesson_id == lesson_id).all()
    
    # Don't send correct answers to client
    return [{
        "id": q.id,
        "question_text": q.question_text,
        "question_type": q.question_type.value,
        "options": q.options,
        "difficulty": q.difficulty.value,
        "points": q.points,
        "image_url": q.image_url
    } for q in questions]

# Quiz endpoints
@app.post("/api/quizzes", status_code=status.HTTP_201_CREATED)
async def create_quiz(
    quiz_data: QuizCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    new_quiz = Quiz(
        id=str(uuid4()),
        topic_id=quiz_data.topic_id,
        title=quiz_data.title,
        description=quiz_data.description,
        time_limit=quiz_data.time_limit,
        passing_score=quiz_data.passing_score,
        is_published=True
    )
    
    db.add(new_quiz)
    db.flush()
    
    # Add questions to quiz
    for question_id in quiz_data.question_ids:
        question = db.query(Question).filter(Question.id == question_id).first()
        if question:
            new_quiz.questions.append(question)
    
    db.commit()
    db.refresh(new_quiz)
    return new_quiz

@app.get("/api/quizzes/{quiz_id}")
async def get_quiz(quiz_id: str, db: Session = Depends(get_db)):
    quiz = db.query(Quiz).filter(Quiz.id == quiz_id).first()
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    
    # Get questions without answers
    questions = [{
        "id": q.id,
        "question_text": q.question_text,
        "question_type": q.question_type.value,
        "options": q.options,
        "difficulty": q.difficulty.value,
        "points": q.points
    } for q in quiz.questions]
    
    return {
        "id": quiz.id,
        "title": quiz.title,
        "description": quiz.description,
        "time_limit": quiz.time_limit,
        "passing_score": quiz.passing_score,
        "questions": questions
    }

@app.post("/api/quizzes/{quiz_id}/submit")
async def submit_quiz(
    quiz_id: str,
    submission: QuizSubmission,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    quiz = db.query(Quiz).filter(Quiz.id == quiz_id).first()
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    
    # Check attempt limit
    attempts = db.query(QuizAttempt).filter(
        QuizAttempt.user_id == user_id,
        QuizAttempt.quiz_id == quiz_id
    ).count()
    
    if attempts >= quiz.max_attempts:
        raise HTTPException(status_code=400, detail="Maximum attempts reached")
    
    # Calculate score
    score = 0
    total_points = 0
    results = []
    
    for question in quiz.questions:
        total_points += question.points
        user_answer = submission.answers.get(question.id, "").strip().lower()
        correct_answer = question.correct_answer.strip().lower()
        is_correct = user_answer == correct_answer
        
        if is_correct:
            score += question.points
        
        results.append({
            "question_id": question.id,
            "correct": is_correct,
            "user_answer": user_answer,
            "correct_answer": question.correct_answer,
            "explanation": question.explanation
        })
    
    percentage = (score / total_points * 100) if total_points > 0 else 0
    passed = percentage >= quiz.passing_score
    
    # Save attempt
    attempt = QuizAttempt(
        id=str(uuid4()),
        user_id=user_id,
        quiz_id=quiz_id,
        score=score,
        total_points=total_points,
        percentage=percentage,
        passed=passed,
        time_taken=0,  # Should be tracked on frontend
        answers=submission.answers,
        results=results,
        started_at=datetime.utcnow()
    )
    
    db.add(attempt)
    db.commit()
    
    return {
        "score": score,
        "total": total_points,
        "percentage": percentage,
        "passed": passed,
        "results": results,
        "attempt_number": attempts + 1
    }

# Experiment endpoints
@app.get("/api/subjects/{subject}/experiments")
async def get_experiments(subject: SubjectEnum, db: Session = Depends(get_db)):
    experiments = db.query(Experiment).filter(
        Experiment.subject == subject,
        Experiment.is_published == True
    ).all()
    return experiments

@app.post("/api/experiments", status_code=status.HTTP_201_CREATED)
async def create_experiment(
    experiment_data: ExperimentCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    new_experiment = Experiment(
        id=str(uuid4()),
        subject=experiment_data.subject,
        title=experiment_data.title,
        objective=experiment_data.objective,
        theory=experiment_data.theory,
        materials=experiment_data.materials,
        procedure=experiment_data.procedure,
        safety_precautions=experiment_data.safety_precautions,
        observations=experiment_data.observations,
        difficulty=experiment_data.difficulty,
        grade=experiment_data.grade,
        estimated_time=experiment_data.estimated_time,
        is_published=True
    )
    
    db.add(new_experiment)
    db.commit()
    db.refresh(new_experiment)
    return new_experiment

@app.get("/api/experiments/{experiment_id}")
async def get_experiment(experiment_id: str, db: Session = Depends(get_db)):
    experiment = db.query(Experiment).filter(Experiment.id == experiment_id).first()
    if not experiment:
        raise HTTPException(status_code=404, detail="Experiment not found")
    return experiment

# Bookmark endpoints
@app.post("/api/bookmarks/{lesson_id}")
async def add_bookmark(
    lesson_id: str,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    # Check if already bookmarked
    existing = db.query(Bookmark).filter(
        Bookmark.user_id == user_id,
        Bookmark.lesson_id == lesson_id
    ).first()
    
    if existing:
        raise HTTPException(status_code=400, detail="Already bookmarked")
    
    bookmark = Bookmark(
        id=str(uuid4()),
        user_id=user_id,
        lesson_id=lesson_id
    )
    
    db.add(bookmark)
    db.commit()
    return {"message": "Bookmark added"}

@app.delete("/api/bookmarks/{lesson_id}")
async def remove_bookmark(
    lesson_id: str,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    bookmark = db.query(Bookmark).filter(
        Bookmark.user_id == user_id,
        Bookmark.lesson_id == lesson_id
    ).first()
    
    if not bookmark:
        raise HTTPException(status_code=404, detail="Bookmark not found")
    
    db.delete(bookmark)
    db.commit()
    return {"message": "Bookmark removed"}

@app.get("/api/bookmarks")
async def get_bookmarks(user_id: str = Depends(verify_token), db: Session = Depends(get_db)):
    bookmarks = db.query(Bookmark).filter(Bookmark.user_id == user_id).all()
    
    result = []
    for bookmark in bookmarks:
        lesson = db.query(Lesson).filter(Lesson.id == bookmark.lesson_id).first()
        if lesson:
            result.append({
                "bookmark_id": bookmark.id,
                "lesson": LessonResponse.from_orm(lesson),
                "created_at": bookmark.created_at
            })
    
    return result

# Notes endpoints
@app.post("/api/notes", status_code=status.HTTP_201_CREATED)
async def create_note(
    note_data: NoteCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    note = Note(
        id=str(uuid4()),
        user_id=user_id,
        lesson_id=note_data.lesson_id,
        title=note_data.title,
        content=note_data.content,
        color=note_data.color
    )
    
    db.add(note)
    db.commit()
    db.refresh(note)
    return note

@app.get("/api/notes")
async def get_notes(
    lesson_id: Optional[str] = None,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    query = db.query(Note).filter(Note.user_id == user_id)
    
    if lesson_id:
        query = query.filter(Note.lesson_id == lesson_id)
    
    notes = query.order_by(Note.updated_at.desc()).all()
    return notes

@app.put("/api/notes/{note_id}")
async def update_note(
    note_id: str,
    note_data: NoteCreate,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    note = db.query(Note).filter(Note.id == note_id, Note.user_id == user_id).first()
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    
    note.title = note_data.title
    note.content = note_data.content
    note.color = note_data.color
    note.updated_at = datetime.utcnow()
    
    db.commit()
    return note

@app.delete("/api/notes/{note_id}")
async def delete_note(
    note_id: str,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    note = db.query(Note).filter(Note.id == note_id, Note.user_id == user_id).first()
    if not note:
        raise HTTPException(status_code=404, detail="Note not found")
    
    db.delete(note)
    db.commit()
    return {"message": "Note deleted"}

# Progress and Analytics endpoints
@app.get("/api/progress/dashboard")
async def get_dashboard(user_id: str = Depends(verify_token), db: Session = Depends(get_db)):
    # Get completed lessons count
    completed_lessons = db.query(UserProgress).filter(
        UserProgress.user_id == user_id,
        UserProgress.completed == True
    ).count()
    
    # Get total time spent
    total_time = db.query(func.sum(UserProgress.time_spent)).filter(
        UserProgress.user_id == user_id
    ).scalar() or 0
    
    # Get quiz attempts
    quiz_attempts = db.query(QuizAttempt).filter(
        QuizAttempt.user_id == user_id
    ).all()
    
    avg_score = sum(a.percentage for a in quiz_attempts) / len(quiz_attempts) if quiz_attempts else 0
    passed_quizzes = sum(1 for a in quiz_attempts if a.passed)
    
    # Get study streak
    streak = db.query(StudyStreak).filter(StudyStreak.user_id == user_id).first()
    
    # Recent activity
    recent_progress = db.query(UserProgress).filter(
        UserProgress.user_id == user_id
    ).order_by(UserProgress.last_accessed.desc()).limit(10).all()
    
    return {
        "total_lessons_completed": completed_lessons,
        "total_time_spent": total_time,
        "average_quiz_score": round(avg_score, 2),
        "passed_quizzes": passed_quizzes,
        "current_streak": streak.current_streak if streak else 0,
        "longest_streak": streak.longest_streak if streak else 0,
        "recent_activity": [{
            "lesson_id": p.lesson_id,
            "completed": p.completed,
            "last_accessed": p.last_accessed
        } for p in recent_progress]
    }

@app.get("/api/progress/subject/{subject}")
async def get_subject_progress(
    subject: SubjectEnum,
    user_id: str = Depends(verify_token),
    db: Session = Depends(get_db)
):
    # Get all topics for subject
    topics = db.query(Topic).filter(Topic.subject == subject).all()
    
    progress_data = []
    for topic in topics:
        lessons = db.query(Lesson).filter(Lesson.topic_id == topic.id).all()
        lesson_ids = [l.id for l in lessons]
        
        completed = db.query(UserProgress).filter(
            UserProgress.user_id == user_id,
            UserProgress.lesson_id.in_(lesson_ids),
            UserProgress.completed == True
        ).count()
        
        progress_data.append({
            "topic_id": topic.id,
            "topic_title": topic.title,
            "total_lessons": len(lessons),
            "completed_lessons": completed,
            "progress_percentage": (completed / len(lessons) * 100) if lessons else 0
        })
    
    return progress_data

@app.get("/api/leaderboard")
async def get_leaderboard(
    subject: Optional[SubjectEnum] = None,
    grade: Optional[int] = None,
    db: Session = Depends(get_db)
):
    # Get all users with their scores
    query = db.query(
        User.id,
        User.username,
        User.profile_picture,
        User.grade,
        func.count(UserProgress.id).label('completed_lessons'),
        func.sum(QuizAttempt.score).label('total_score')
    ).outerjoin(UserProgress, User.id == UserProgress.user_id)\
     
